<!doctype html>
<html>
    <head>
        <title>CD - Compiler Design CS_2</title>
        <meta charset='utf-8'/>
        <style>
body {
  background-color: black;
  color: white;
  margin-left: 15%;
  margin-right: 15%;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

div {
  color: white;
}

img {
  margin-top: auto;
  margin-bottom: auto;
  max-width: 80%;
}

p {
  font-size: large;
}

li {
  font-size: large;
}

.scrollmenu {
  overflow: auto;
  max-height: 55vh;
  white-space: nowrap;
  text-align: left;
}

table {
  border-collapse: collapse;
  width: 100%;
}

th {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: center;
}

td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: center;
}

/* Highlight styling for dark mode */
.highlight {
  background-color: #333;
  color: #fff;
  padding: 0;
  margin: 0;
  border: none;
  display: inline;
}

</style>
    </head>
    <body>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_1.png" src="slides/Pasted image 20250209093804_1.png" class="internal-embed"></p>
<p dir="auto">Alright, it looks like we're starting a course on Compiler Design! This slide serves as the title page. We see the course name, Compiler Design, along with the course code SSWTZC373. It's presented by BITS Pilani, with campuses listed in Pilani, Dubai, Goa, and Hyderabad. We can see the institution's logo as well.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_2.png" src="slides/Pasted image 20250209093804_2.png" class="internal-embed"></p>
<p dir="auto">Okay, this slide marks the beginning of Contact Session 2 and is an introduction to the Lexical Analyzer. The Lexical Analyzer is the first phase of a compiler, responsible for breaking down the source code into a stream of tokens.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_3.png" src="slides/Pasted image 20250209093804_3.png" class="internal-embed"></p>
<p dir="auto">This slide delves deeper into the Lexical Analyzer, also known as the Scanner. The slide outlines some key functions and advantages of the lexical analyzer:</p>
<ul>
<li dir="auto"><strong>Linear analysis:</strong> It's the only part of the compiler that examines each character of the source text and performs a linear analysis, meaning it reads through the code sequentially.</li>
<li dir="auto"><strong>Token production:</strong> It reads the source text and produces tokens, which are the fundamental building blocks for the next stages of the compiler. Examples of tokens include keywords (like 'if', 'else'), identifiers (variable names), operators (+, -, *), and literals (numbers, strings).</li>
<li dir="auto"><strong>Source coordinates:</strong> It keeps track of source coordinates, like the filename, line number, and position of each token. This is crucial for debugging and reporting errors, allowing the compiler to pinpoint exactly where a problem occurs in the original code.</li>
<li dir="auto"><strong>Advantages:</strong> Finally, it lists the advantages of having a separate lexical analyzer which include:
<ul>
<li dir="auto">Keeps compiler design simple</li>
<li dir="auto">Improves efficiency</li>
<li dir="auto">Increases portability</li>
</ul>
</li>
</ul>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_4.png" src="slides/Pasted image 20250209093804_4.png" class="internal-embed"></p>
<p dir="auto">This slide visually illustrates the role of the Lexical Analyzer within a compiler. Let's break down the diagram:</p>
<ul>
<li dir="auto"><strong>Source Program:</strong> At the bottom, we have the source program, which is the original code written by the programmer. The Lexical Analyzer reads this program character by character.</li>
<li dir="auto"><strong>Lexical Analyzer:</strong> In the center is the Lexical Analyzer itself, depicted as a system with gears. It receives the source code, "get next char" from the source program, and produces tokens.</li>
<li dir="auto"><strong>Syntax Analyzer:</strong> The tokens generated by the Lexical Analyzer are then passed on to the Syntax Analyzer (also known as the Parser). The Syntax Analyzer uses these tokens to build a parse tree, which represents the grammatical structure of the code.</li>
<li dir="auto"><strong>Symbol Table:</strong> There's also a connection to the symbol table, which the Lexical Analyzer and Syntax Analyzer both interact with. The symbol table stores information about the identifiers (variables, function names, etc.) used in the program, like their data types and scope. The Lexical Analyzer will add identifiers to the symbol table and the Syntax Analyzer will also use information in the table.</li>
</ul>
<p dir="auto">In essence, the slide demonstrates the Lexical Analyzer's crucial role in the compilation process. It's the initial step in transforming the raw source code into a more structured form that can be understood by the subsequent phases of the compiler.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_5.png" src="slides/Pasted image 20250209093804_5.png" class="internal-embed"></p>
<p dir="auto">This slide introduces some key terminologies related to the Lexical Analyzer:</p>
<ul>
<li dir="auto"><strong>Token:</strong> A group of characters that have a collective meaning. Think of it as a category or a classification.</li>
<li dir="auto"><strong>Lexeme:</strong> This is a particular instance, or the actual sequence of characters, for a token. It is the concrete realization of a token in the source code. The example given is a token of type "identifier" and a lexeme is "pi".</li>
<li dir="auto"><strong>Pattern:</strong> The rule describing how a token can be formed. The example given shows how an identifier is formed with a combination of letters and numbers.</li>
</ul>
<p dir="auto">The slide also reiterates a point made earlier: the Lexical Analyzer doesn't necessarily have to be a separate phase of compilation, but it is beneficial as it simplifies the design, and improves efficiency and portability.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093804_6.png" src="slides/Pasted image 20250209093804_6.png" class="internal-embed"></p>
<p dir="auto">This slide continues to clarify the concepts of tokens, patterns, and lexemes, which are fundamental to understanding the role of a Lexical Analyzer.</p>
<p dir="auto">The slide begins by defining what tokens are.</p>
<ul>
<li dir="auto"><strong>What are tokens?</strong>
<ul>
<li dir="auto">Basic lexical units: Tokens represent the most fundamental building blocks of the programming language.</li>
<li dir="auto">Sequence of abstract characters: A token is a sequence of abstract characters that form a unit in a grammar.</li>
<li dir="auto">Finite set of token types: Programming languages classify the tokens into a finite set of token types.</li>
</ul>
</li>
</ul>
<p dir="auto">The slide also includes a note on terminology:</p>
<ul>
<li dir="auto">The slide notes that some texts use the terms "token types" and "tokens" differently, but the course will stick to the terms "tokens" and "token types."</li>
</ul>
<p dir="auto">Finally, the slide explains that some tokens might have attributes. For example, integer constant tokens have the actual integer value as an attribute (e.g., 17, 42), while identifiers have a string representing the actual identifier's name as an attribute.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_7.png" src="slides/Pasted image 20250209093805_7.png" class="internal-embed"></p>
<p dir="auto">Now, we get a practical example to illustrate what tokens look like within a code segment.</p>
<ul>
<li dir="auto"><strong>Example Program Segment:</strong> The slide shows a small C code snippet: 
void main() { printf("Hello World\n"); }
</li>
<li dir="auto"><strong>Token Breakdown:</strong> The slide then lists each token in the code:
<ol>
<li dir="auto">
void
</li>
<li dir="auto">
main
</li>
<li dir="auto">
(
</li>
<li dir="auto">
)
</li>
<li dir="auto">
{
</li>
<li dir="auto">
printf
</li>
<li dir="auto">
(
</li>
<li dir="auto">
"Hello World\n"
</li>
<li dir="auto">
)
</li>
<li dir="auto">
;
</li>
<li dir="auto">
}
</li>
</ol>
</li>
</ul>
<p dir="auto">This is a clear and direct way to show how the Lexical Analyzer would break down this code into a stream of tokens. Each keyword, identifier, operator, and literal (like the string 
"Hello World\n"
) becomes an individual token.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_8.png" src="slides/Pasted image 20250209093805_8.png" class="internal-embed"></p>
<p dir="auto">This slide is about the specifications of tokens, relating to the concept of strings. Let's go through the terms:</p>
<ul>
<li dir="auto"><strong>1. Prefix of s:</strong> A string obtained by deleting trailing symbols. Essentially, it's a portion of the string starting from the beginning.</li>
<li dir="auto"><strong>2. Suffix of s:</strong> A string obtained by deleting leading symbols. This is a portion of the string that appears at the end.</li>
<li dir="auto"><strong>3. Substring of s:</strong> A string obtained by deleting a prefix and a suffix. This is a contiguous sequence of characters within the string.</li>
<li dir="auto"><strong>4. Proper:</strong> A prefix, suffix, or substring that is non-empty and not equal to the entire string (s != x).</li>
<li dir="auto"><strong>5. Subsequence of s:</strong> A string obtained by deleting symbols that are not necessarily contiguous. This means the characters can be in any order, as long as they appear in the original string.</li>
</ul>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_9.png" src="slides/Pasted image 20250209093805_9.png" class="internal-embed"></p>
<p dir="auto">This slide introduces "The Principle of Longest Match," which is a key concept in how lexical analyzers work.</p>
<ul>
<li dir="auto"><strong>Principle of Longest Match:</strong> In most programming languages, the scanner (lexical analyzer) is designed to pick the longest possible string of characters to make up the next token when there are multiple possible matches.</li>
<li dir="auto"><strong>Example:</strong> The slide provides an example to illustrate this. Let's consider the code: 
return foobar != hohum;

<ul>
<li dir="auto">The lexical analyzer should recognize this as five tokens.</li>
<li dir="auto">The tokens would be: 
RETURN
, 
ID(foobar)0
, 
NEQ
, 
ID(hohum)
, 
SCOLON
.</li>
<li dir="auto">
!=
 is correctly recognized as the "not equal" operator, while 
!
 and 
=
 would not be separate tokens, as the longest possible string is taken. Similarly, 
foobar
 and 
hohum
 are correctly recognized as a single identifier token.</li>
</ul>
</li>
</ul>
<p dir="auto">This principle helps to resolve ambiguities in the source code and ensures that tokens are formed in a consistent and predictable manner.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_10.png" src="slides/Pasted image 20250209093805_10.png" class="internal-embed"></p>
<p dir="auto">This slide shows a breakdown of typical token types found in programming languages. Let's examine each category:</p>
<ul>
<li dir="auto"><strong>Operators &amp; Punctuation:</strong> This includes symbols such as 
+
, 
-
, 
*
, 
/
, 
(
, 
)
, 
{
, 
}
, 
[
, 
]
, 
;
, 
:
, 
<
, 
<=
, 
==
, 
=
, 
!=
, 
!
, etc. Each of these symbols represents a distinct lexical class or token type.</li>
<li dir="auto"><strong>Keywords:</strong> Keywords are reserved words in a programming language that have special meanings. Examples here include 
if
, 
while
, 
for
, 
goto
, 
return
, 
switch
, and 
void
. Like operators and punctuation, each keyword is a distinct lexical class.</li>
<li dir="auto"><strong>Identifiers:</strong> Identifiers are names given to variables, functions, and other program elements. Identifiers are a single lexical class, but their specific values are parameterized by the actual identifier's name (the string of characters used to represent the identifier).</li>
<li dir="auto"><strong>Integer Constants:</strong> These are numerical values that represent whole numbers. They belong to a single lexical class (e.g., 
INT
), and they are parameterized by their actual integer value (e.g., 10, -5, 1000).</li>
<li dir="auto"><strong>Other Constants:</strong> This category would encompass other types of constants such as floating-point numbers, character constants, string literals, and boolean constants. Each of these has its own distinct lexical class.</li>
</ul>
<p dir="auto">This breakdown is important for understanding the different categories of tokens that a lexical analyzer must identify and classify to produce a stream of tokens for the subsequent phases of the compiler.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_11.png" src="slides/Pasted image 20250209093805_11.png" class="internal-embed"></p>
<p dir="auto">This slide provides a table summarizing different token types typically found in programming languages, along with examples:</p>
<ul>
<li dir="auto"><strong>ID (Identifiers):</strong>  These are names used for variables, functions, etc. Examples include 
foo
, 
n14
, 
a
, 
temp
.</li>
<li dir="auto"><strong>NUM (Numbers):</strong> This represents integer constants. Examples: 
73
, 
0
, 
00
, 
515
, 
+2
.</li>
<li dir="auto"><strong>REAL (Real Numbers):</strong>  This represents floating-point or decimal numbers. Examples: 
66.1
, 
.5
, 
10.
, 
1e67
, 
5.5e-10
. The examples show the various forms of floating point numbers.</li>
<li dir="auto"><strong>KEYWORDS:</strong> These are reserved words with special meanings. Examples: 
IF
, 
DO
, 
WHILE
, 
INT
.</li>
<li dir="auto"><strong>SYMBOLS:</strong> These include operators, punctuation, and other special characters. Examples include 
,
 (comma), 
!=
 (not equal), and 
(
 (left parenthesis).</li>
</ul>
<p dir="auto">This table gives a clear overview of the variety of tokens the Lexical Analyzer has to identify.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_12.png" src="slides/Pasted image 20250209093805_12.png" class="internal-embed"></p>
<p dir="auto">This slide reinforces how tokens are formally defined and recognized.</p>
<ul>
<li dir="auto"><strong>Question:</strong> How are tokens formally defined and recognized?</li>
<li dir="auto"><strong>Answer:</strong> By using regular expressions to define a token as a formal regular language.</li>
</ul>
<p dir="auto">In essence, regular expressions are used to specify the patterns that tokens must match. The lexical analyzer uses these regular expressions to scan the source code and identify valid tokens. Regular expressions provide a concise and powerful way to describe the structure of tokens such as identifiers, numbers, keywords, and symbols.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_13.png" src="slides/Pasted image 20250209093805_13.png" class="internal-embed"></p>
<p dir="auto">This slide presents a formal definition of languages, which is fundamental to the understanding of how compilers work.</p>
<ul>
<li dir="auto"><strong>Alphabet:</strong> A finite (non-empty) set of symbols, typically denoted by the Greek letter Sigma (Σ). This is the set of basic building blocks used to construct strings.</li>
<li dir="auto"><strong>String:</strong> A finite sequence of symbols from an alphabet. This includes the empty sequence (denoted by lambda, λ), which contains no symbols.</li>
<li dir="auto"><strong>Language:</strong> A set (often infinite) of finite strings. It is a collection of valid strings that conform to the rules of a given language. The set of all possible finite strings of elements of an alphabet Σ, (including λ) is denoted by Σ*.</li>
<li dir="auto"><strong>Finite specifications of (possibly infinite) languages is possible with:</strong> It is possible to define languages, even infinite ones, using finite representations. The slide then lists two key ways to do this:
<ol>
<li dir="auto"><strong>Automaton:</strong> A recognizer. It's a machine that accepts all strings in a language and rejects all other strings (strings that are not part of the language). Think of this as a system that determines whether a string is "valid."</li>
<li dir="auto"><strong>Grammar:</strong> A generator. It is a system for producing all strings in the language and no other strings (strings that are not part of the language). This approach generates valid strings based on a set of rules.</li>
</ol>
</li>
</ul>
<p dir="auto">The formal definition of languages is the foundation upon which the techniques used in lexical analysis and parsing are built. Automata and grammars are powerful tools to describe and recognize patterns in the input source code.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093805_14.png" src="slides/Pasted image 20250209093805_14.png" class="internal-embed"></p>
<p dir="auto">This slide continues the discussion on the formal definition of languages, providing several examples.</p>
<ul>
<li dir="auto"><strong>Recap:</strong> It reiterates that a language L over an alphabet Σ is a collection of strings of elements from Σ. This definition lays the groundwork for understanding the concept of a language.</li>
<li dir="auto"><strong>Examples of Languages:</strong>
<ul>
<li dir="auto"><strong>The PASCAL Language:</strong> This is the set of all strings that constitute legal PASCAL programs. Since there are many valid PASCAL programs of varying sizes and complexities, this is an infinite set.</li>
<li dir="auto"><strong>The Language of Primes:</strong> This is the set of all decimal digit strings that constitute prime numbers. Because there is an infinite number of primes, this is an infinite set.</li>
<li dir="auto"><strong>The language of C reserved words:</strong> This is the set of all alphabetic strings that cannot be used as identifiers in the C programming language. This is a finite set.</li>
</ul>
</li>
<li dir="auto"><strong>Regular Expressions:</strong> The slide then states that, to specify some of these possibly infinite languages with a finite description, we use the notation of Regular Expressions.</li>
</ul>
<p dir="auto">This slide is building up to the connection of regular expressions with lexical analysis. It’s setting the scene for how we can formally describe the structure of tokens.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_15.png" src="slides/Pasted image 20250209093806_15.png" class="internal-embed"></p>
<p dir="auto">This slide provides key concepts related to Regular Expressions.</p>
<ul>
<li dir="auto"><strong>Defined over an Alphabet:</strong> A regular expression is always defined over some alphabet (Σ). This alphabet is the set of all possible symbols that can be used in the strings that the regular expression describes. In the context of programming languages, the alphabet is typically ASCII or Unicode.</li>
<li dir="auto"><strong>L(E) is the "Language":</strong> If E is a regular expression, then L(E) represents the "language," which is the set of strings generated or matched by E.</li>
<li dir="auto"><strong>Example: {a}</strong> For each symbol 'a' in the alphabet, the regular expression 
{a}
 denotes a language containing just the single string "a." This is known as a symbol.</li>
<li dir="auto"><strong>Empty sequence (λ):</strong> A regular expression generated with an empty sequence λ (lambda) is denoted by ε (epsilon).</li>
</ul>
<p dir="auto">Regular expressions provide a precise notation to define the structure of the different tokens. They are used to specify the patterns of characters that constitute valid tokens. The lexical analyzer uses these regular expressions to match patterns in the source code.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_16.png" src="slides/Pasted image 20250209093806_16.png" class="internal-embed"></p>
<p dir="auto">This slide gives the formal definition of regular expressions using a set of rules, or operations:</p>
<ul>
<li dir="auto"><strong>Given an Alphabet (Σ):</strong> The rules define how regular expressions are built from the alphabet's symbols.</li>
<li dir="auto"><strong>(1) ε (Epsilon):</strong> This is a regular expression that denotes the set containing the empty string.</li>
<li dir="auto"><strong>(2) For each a ∈ Σ (Sigma):</strong> "a" is a regular expression that denotes {a}, the set containing the string "a."</li>
<li dir="auto"><strong>(3) If r and s are regular expressions denoting the languages (sets) L(r) and L(s), then:</strong> This defines how to build more complex regular expressions from simpler ones using three main operations:
<ul>
<li dir="auto"><strong>(r) | (s):</strong> This is a regular expression denoting L(r) ∪ L(s). The "|" symbol represents "or" or union, meaning the expression matches strings in either L(r) or L(s).</li>
<li dir="auto"><strong>(r)(s):</strong> This is a regular expression denoting L(r)L(s). This is concatenation, meaning the expression matches any string formed by concatenating a string from L(r) with a string from L(s).</li>
<li dir="auto"><strong>(r)*:</strong> This is a regular expression denoting (L(r))*. The "*" symbol represents the Kleene star (or closure), meaning it matches zero or more repetitions of strings from L(r).</li>
</ul>
</li>
</ul>
<p dir="auto">Finally, it points out that a regular expression is defined together with the language it denotes.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_17.png" src="slides/Pasted image 20250209093806_17.png" class="internal-embed"></p>
<p dir="auto">This slide provides examples to help understand regular expressions and their notation.</p>
<ul>
<li dir="auto"><strong>Alphabet:</strong> The examples use the alphabet Σ = {a, b}. This means the regular expressions can only use the symbols 'a' and 'b'.</li>
<li dir="auto"><strong>Examples:</strong>
<ul>
<li dir="auto">
a | b
: This means "a or b." The language contains either the string "a" or the string "b."</li>
<li dir="auto">
(a | b)(a | b)
: This matches a string that is either "aa", "ab", "ba", or "bb". It is a concatenation of two symbols, each of which can be 'a' or 'b'.</li>
<li dir="auto">
a*
: This matches zero or more occurrences of the character 'a'. The language includes "", "a", "aa", "aaa", and so on.</li>
<li dir="auto">
(a | b)*
: This matches any string composed of zero or more 'a's and 'b's, in any order. This effectively matches any string composed of 'a' and 'b'.</li>
<li dir="auto">
a | a*b
: This matches the string "a" or any string that begins with zero or more 'a's followed by a single 'b'. It includes strings like "a", "b", "ab", "aab", "aaab", etc.</li>
</ul>
</li>
<li dir="auto"><strong>Precedence and Associativity:</strong> The slide also outlines operator precedence and associativity, similar to arithmetic operators:
<ul>
<li dir="auto">
*
 (Kleene Star): Highest precedence and left-associative.</li>
<li dir="auto">Concatenation: Second-highest precedence and left-associative.</li>
<li dir="auto">
|
 (or/union): Lowest precedence and left-associative.</li>
</ul>
</li>
<li dir="auto"><strong>Example of Operator Precedence:</strong> The example 
(a) | ((b)*(c)) = a | b*c
 illustrates how operator precedence affects the interpretation of a regular expression. Because the Kleene star has higher precedence than concatenation, 
b*c
 is interpreted as a Kleene star applied to 'b', followed by concatenation with 'c'.</li>
</ul>
<p dir="auto">The slide demonstrates how regular expressions are used to describe and specify patterns of strings based on a given alphabet. These regular expressions form the basis for defining tokens in the lexical analyzer.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_18.png" src="slides/Pasted image 20250209093806_18.png" class="internal-embed"></p>
<p dir="auto">This slide is about the core operations used with regular expressions:</p>
<ul>
<li dir="auto"><strong>Alternation (denoted by |):</strong> This operation, often represented by the "or" symbol (|), creates a new regular expression M | N, that represents the "union" of the languages L(M) and L(N). This means the resulting regular expression matches strings that are in either L(M) or L(N).</li>
<li dir="auto"><strong>Concatenation (denoted by . or by juxtaposition):</strong> This operation creates a new regular expression MN that matches a string from L(M) followed by a string from L(N).</li>
<li dir="auto"><strong>The Repetition (denoted by *):</strong> This operation creates a new expression that denotes a language that has 0 or more occurrences (Kleene closure) of L(M).</li>
</ul>
<p dir="auto">These three operations - alternation, concatenation, and repetition - are the foundation for building all regular expressions.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_19.png" src="slides/Pasted image 20250209093806_19.png" class="internal-embed"></p>
<p dir="auto">This slide provides several examples of regular expressions, along with the languages they define and some example words that belong to those languages.</p>
<ul>
<li dir="auto">
a | b
:
<ul>
<li dir="auto">Language: {a, b} (The set containing "a" or "b")</li>
<li dir="auto">Example Words: a, b</li>
</ul>
</li>
<li dir="auto">
ab*a
:
<ul>
<li dir="auto">Language: {a}{b}*{a} (Matches "a" followed by zero or more "b"s, then followed by "a")</li>
<li dir="auto">Example Words: aa, aba, abba, abbba</li>
</ul>
</li>
<li dir="auto">
(ab)*
:
<ul>
<li dir="auto">Language: {ab}* (Matches zero or more repetitions of "ab")</li>
<li dir="auto">Example Words: ε (the empty string), ab, abab, ababab, ...</li>
</ul>
</li>
<li dir="auto">
abba
:
<ul>
<li dir="auto">Language: {abba} (Matches only the string "abba")</li>
<li dir="auto">Example Words: abba</li>
</ul>
</li>
<li dir="auto">
(0 | 1)*0
:
<ul>
<li dir="auto">Language: {0}{1}* {0} (Matches strings of 0s and 1s that end in 0. This represents all binary even numbers).</li>
<li dir="auto">Example Words: 0, 00, 10, 010, 110, ... (All binary even numbers)</li>
</ul>
</li>
<li dir="auto">
b*(abb*)*(a | ε)
:
<ul>
<li dir="auto">Language: Strings of a and b with NO consecutive a (Matches strings of 'a' and 'b' where no two 'a's are next to each other.)</li>
<li dir="auto">Example Words: Strings of a and b with NO consecutive a</li>
</ul>
</li>
</ul>
<p dir="auto">The slide concludes by stating that we can specify regular expressions corresponding to the lexical tokens of a programming language using the symbols, |, ., *, and ε.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_20.png" src="slides/Pasted image 20250209093806_20.png" class="internal-embed"></p>
<p dir="auto">This slide provides a table of operators and abbreviations commonly used in regular expressions. This is a useful reference for understanding and writing regular expressions.</p>
<ul>
<li dir="auto"><strong>a:</strong> An ordinary character that stands for itself.</li>
<li dir="auto"><strong>ε (epsilon):</strong> The empty string (a string with no characters).</li>
<li dir="auto"><strong>M | N:</strong> Alternation; Choosing from M OR N.</li>
<li dir="auto"><strong>MN:</strong> Concatenation: An M followed by N.</li>
<li dir="auto"><strong>M*:</strong> Repetition (zero or more times) - Kleene star.</li>
<li dir="auto"><strong>M+:</strong> Repetition (one or more times).</li>
<li dir="auto"><strong>M?:</strong> Optional (zero or one occurrence of M).</li>
<li dir="auto"><strong>[a-z A-Z]:</strong> Character set alternation (matches any lowercase or uppercase letter).</li>
<li dir="auto"><strong>[abxyz]:</strong> One of the given characters (a | b | x | y | z).</li>
<li dir="auto"><strong>. (dot):</strong> Stands for a single character (except newline).</li>
<li dir="auto">
'a..+'
: Quotation: A string in quotes stands for itself literally.</li>
</ul>
<p dir="auto">This table provides a concise summary of the regular expression notations that the lexical analyzer will use.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_21.png" src="slides/Pasted image 20250209093806_21.png" class="internal-embed"></p>
<p dir="auto">This slide presents a set of problems related to designing regular expressions. The objective here is to translate the described languages into their corresponding regular expression notations.</p>
<ul>
<li dir="auto"><strong>Problem 1:</strong>
<ul>
<li dir="auto">L = {w ∈ {a, b}* : every a in w is immediately preceded and followed by b}.</li>
<li dir="auto">This language consists of strings of 'a' and 'b' where every 'a' is always surrounded by 'b's. This means, all 'a's must be in the form of "bab".</li>
</ul>
</li>
<li dir="auto"><strong>Problem 2:</strong>
<ul>
<li dir="auto">L = {w ∈ {a, b}* : |w| is even}.</li>
<li dir="auto">This language includes strings of 'a's and 'b's where the length of the string is even.</li>
</ul>
</li>
<li dir="auto"><strong>Problem 3:</strong>
<ul>
<li dir="auto">L = {w ∈ {0, 1}* : the third character is 0}.</li>
<li dir="auto">This language consists of binary strings (made of '0's and '1's) where the third character in the string is always '0'.</li>
</ul>
</li>
<li dir="auto"><strong>Problem 4:</strong>
<ul>
<li dir="auto">L = {w ∈ {a, b}* : w contains an odd number of a's}.</li>
<li dir="auto">This language is comprised of strings of 'a's and 'b's where the number of 'a's in the string is an odd number (1, 3, 5, etc.).</li>
</ul>
</li>
</ul>
<p dir="auto">These problems are designed to test the ability to translate natural language descriptions of string patterns into the formal notation of regular expressions.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_22.png" src="slides/Pasted image 20250209093806_22.png" class="internal-embed"></p>
<p dir="auto">This slide presents more problems related to designing regular expressions.</p>
<ul>
<li dir="auto"><strong>Problem 5:</strong>
<ul>
<li dir="auto">L = {w ∈ {0, 1}* : at most one pair consecutive 1's}.</li>
<li dir="auto">This language includes strings of 0's and 1's that can have at most one occurrence of two consecutive 1s ("11").</li>
</ul>
</li>
<li dir="auto"><strong>Problem 6:</strong>
<ul>
<li dir="auto">L = {w ∈ {a, b}* : more than two letters with beginning and ending same letters}.</li>
<li dir="auto">This language describes strings of 'a's and 'b's where the length of the string is greater than 2, and the first and last characters are the same (either both 'a' or both 'b').</li>
</ul>
</li>
<li dir="auto"><strong>Problem 7:</strong>
<ul>
<li dir="auto">L = {w ∈ {0, 1}* : every pair of adjacent 0's appears before any pair of adjacent 1's}.</li>
<li dir="auto">This language encompasses strings of 0s and 1s where if there are any consecutive zeros, they must appear before any consecutive ones. For instance, "0011" is valid, while "1100" is not.</li>
</ul>
</li>
<li dir="auto"><strong>Problem 8:</strong>
<ul>
<li dir="auto">L = {w ∈ {0, 1}* : length of w is odd}.</li>
<li dir="auto">This language includes strings of '0's and '1's that have an odd number of characters in total.</li>
</ul>
</li>
</ul>
<p dir="auto">These problems provide further practice in the design of regular expressions to describe specific string patterns.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093806_23.png" src="slides/Pasted image 20250209093806_23.png" class="internal-embed"></p>
<p dir="auto">This slide provides the solutions to the regular expression problems presented in the previous two slides. Let's go through the solutions:</p>
<ul>
<li dir="auto"><strong>1) (b | bab)*</strong>: This regular expression matches the language where every 'a' is preceded and followed by a 'b'. It starts with either a 'b' or the pattern "bab", repeated zero or more times.</li>
<li dir="auto"><strong>2) ((a | b)(a | b))* or (aa | ab | ba | bb)*</strong>: This matches strings of even length containing 'a' and 'b's. It can be expressed by repeating pairs of 'a' or 'b' characters, or by concatenating the patterns "aa", "ab", "ba", or "bb" zero or more times.</li>
<li dir="auto"><strong>3) (0 | 1)(0 | 1)0(0 | 1)*</strong>: This matches the language where the third character is 0. This expression means that the first two characters can be either '0' or '1', the third must be '0', and the rest can be either '0' or '1' zero or more times.</li>
<li dir="auto"><strong>4) b*(ab*ab*)*ab* or b*a b*(ab*ab*)*</strong>: This matches strings containing an odd number of a's. The regular expressions are slightly different but describe the same language. The strings can begin with zero or more b's, have the sequence "ab*ab*" (an 'a' with any number of 'b's both before and after), and end with zero or more b's, with the sequence "ab*ab*" repeated as many times as needed.</li>
<li dir="auto"><strong>5) (1 | 01)*001*</strong>: This matches strings with at most one pair of consecutive 1's. The expression starts with strings containing "1" or "01", followed by "00" and ends with zero or more "1"s.</li>
<li dir="auto"><strong>6) a (a | b)* a | b (a | b)* b</strong>: This matches strings of more than two letters with the same starting and ending letters. This implies that either the string starts and ends with "a" or "b", and can have any number of 'a' and 'b' in the middle.</li>
<li dir="auto"><strong>7) (1 | 01)*(0 | ε)(0 | 10)*(1 | ε)</strong>: This represents strings where any pair of consecutive 0's appears before any consecutive 1's.</li>
<li dir="auto"><strong>8) (ab | ba | aa | bb)* (a | b)</strong>: This expression represents the strings with an odd number of characters. It can be interpreted that the expressions can contain a sequence of pairs (either aa, ab, ba, bb) followed by 'a' or 'b'.</li>
</ul>
<p dir="auto">These solutions illustrate how regular expressions can be constructed to specify a variety of string patterns.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_24.png" src="slides/Pasted image 20250209093807_24.png" class="internal-embed"></p>
<p dir="auto">This slide focuses on constructing a regular expression for unsigned numbers. This is a good example of how regular expressions can be used to represent numeric patterns.</p>
<ul>
<li dir="auto"><strong>Problem:</strong> Specify a set of unsigned numbers as a regular expression. Examples include 1997 and 19.97.</li>
<li dir="auto"><strong>Observations on numbers:</strong>
<ol>
<li dir="auto">Could be made up of one or more digits from the set (0-9).</li>
<li dir="auto">Optionally, can have a decimal point at the end, followed by 0 or more digits ".(0-9)*".</li>
<li dir="auto">A number can also start with a point followed by one or more digits.</li>
</ol>
</li>
<li dir="auto"><strong>Solution:</strong> The regular expression to match the numbers is given as: 
[(0-9)+ [“.”(0-9)*]? ] | [“.”(0-9) +]

<ul>
<li dir="auto">
[(0-9)+ [“.”(0-9)*]? ]
: This part matches the case where the number starts with one or more digits (0-9), followed optionally by a decimal point and zero or more digits.</li>
<li dir="auto">
|
: The pipe symbol is "or."</li>
<li dir="auto">
[“.”(0-9) +]
: This part handles the case where the number starts with a decimal point and is followed by one or more digits.</li>
</ul>
</li>
</ul>
<p dir="auto">This regular expression covers all the possibilities, making it a robust solution.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_25.png" src="slides/Pasted image 20250209093807_25.png" class="internal-embed"></p>
<p dir="auto">This slide presents a table showing regular expressions used to identify tokens in a programming language. The slide shows the relationship between the regular expression and the token type.</p>
<ul>
<li dir="auto"><strong>if:</strong> The regular expression "if" directly represents the keyword "if". The Token Type would be [Return IF;].</li>
<li dir="auto">
[a-z][a-z0-9]*
: This expression represents an identifier. It starts with a lowercase letter (a-z) and can be followed by zero or more lowercase letters or digits (0-9). The token type would be [return ID ].</li>
<li dir="auto">
[0-9]+
: This expression matches a number. It consists of one or more digits. The Token Type would be [return NUM].</li>
<li dir="auto">
([0-9]+ '.' [0-9]*) | (['.' [0-9]+)
: This is for a real number (floating-point number). It will match integers, decimals, and scientific notation.</li>
<li dir="auto">
('('*[a-z]*'\n')|(') | '\n' | '*/') +
: Regular expression to match comments. This handles the comments with different delimiters.</li>
<li dir="auto">
.
: This represents a catch-all for any invalid or unrecognized characters. The token type is [return ERROR].</li>
</ul>
<p dir="auto">This is a practical example of using regular expressions to specify lexical tokens, which will be used by a lexical analyzer.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_26.png" src="slides/Pasted image 20250209093807_26.png" class="internal-embed"></p>
<p dir="auto">This slide introduces the concept of regular definitions. Regular definitions provide a way to give names to regular expressions, making it easier to build more complex regular expressions. It allows you to break down complex patterns into smaller, named components and reuse those components.</p>
<ul>
<li dir="auto"><strong>Regular definition:</strong> This mechanism gives names to regular expressions, which can then be used to construct more complicated regular expressions.</li>
<li dir="auto"><strong>Formal Notation:</strong> It is expressed as:
<ul>
<li dir="auto">d1 -&gt; r1</li>
<li dir="auto">d2 -&gt; r2</li>
<li dir="auto">...</li>
<li dir="auto">dn -&gt; rn</li>
<li dir="auto">where d1, d2, ..., dn are distinct names, and r1, r2, ..., rn are regular expressions defined over symbols in the alphabet.</li>
</ul>
</li>
<li dir="auto"><strong>Example:</strong> The slide provides an example to demonstrate how regular definitions work:
<ul>
<li dir="auto"><strong>letter -&gt; A | B | C | ... | Z | a | b | ... | z:</strong> Defines "letter" as any uppercase or lowercase English alphabet character.</li>
<li dir="auto"><strong>digit -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9:</strong> Defines "digit" as a number from 0 to 9.</li>
<li dir="auto"><strong>identifier -&gt; letter (letter | digit)*</strong>: Defines "identifier" as a sequence starting with a letter, followed by zero or more letters or digits.</li>
</ul>
</li>
</ul>
<p dir="auto">This is a very common and useful technique in specifying tokens in a programming language.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_27.png" src="slides/Pasted image 20250209093807_27.png" class="internal-embed"></p>
<p dir="auto">This slide explains the role of a regular expression recognizer.</p>
<ul>
<li dir="auto"><strong>Given an input string:</strong> The function of a "regular expression analyzer" is to evaluate if the input string matches the language defined by a given regular expression.</li>
<li dir="auto"><strong>Output:</strong>
<ul>
<li dir="auto"><strong>"YES,"</strong> the input is part of the language generated from the regular expression.</li>
<li dir="auto"><strong>"NO,"</strong> the input isn't part of the language generated from the regular expression.</li>
</ul>
</li>
<li dir="auto"><strong>Automation:</strong> Using results from finite automata theory and the theory of algorithms, we can automate the construction of such recognizers from Regular Expressions.</li>
</ul>
<p dir="auto">This slide provides an overview of how a regular expression recognizer operates. It essentially determines whether a given string matches a specified pattern defined by the regular expression.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_28.png" src="slides/Pasted image 20250209093807_28.png" class="internal-embed"></p>
<p dir="auto">This slide provides the formal definition of the languages associated with regular expressions.</p>
<ul>
<li dir="auto"><strong>Definition of Language L(r):</strong> The language denoted by any regular expression <em>r</em> is defined by the following rules.
<ol>
<li dir="auto"><strong>∅:</strong> ∅ (the empty set) is a regular expression that denotes the empty set {}.</li>
<li dir="auto"><strong>λ:</strong> λ (lambda - the empty string) is a regular expression denoting {λ} (a set containing the empty string).</li>
<li dir="auto"><strong>a:</strong> For every <em>a</em> ∈ Σ (where Σ is the alphabet), <em>a</em> is a regular expression denoting {a} (a set containing the string <em>a</em>).</li>
</ol>
</li>
<li dir="auto"><strong>If r1 and r2 are regular expressions, then:</strong> These rules define how to build more complex regular expressions from simpler ones:<br>
4.  <strong>L(r1 + r2) = L(r1) ∪ L(r2):</strong> The "+" operator (often written as "|") represents union, and the language of r1 + r2 is the union of the languages of r1 and r2.<br>
5.  <strong>L(r1 . r2) = L(r1) L(r2):</strong> The "." (dot) symbol represents concatenation. The language of r1 . r2 is the concatenation of the languages of r1 and r2.<br>
6.  <strong>L((r1)) = L(r1):</strong> Parentheses do not change the language.<br>
7.  <strong>L(r1*) = (L(r1))*:</strong> The asterisk (*) is the Kleene star operator. The language of r1* is zero or more repetitions of the language of r1.</li>
<li dir="auto"><strong>Recursive Nature:</strong> The last four rules of this definition are used to reduce <em>L(r)</em> to simpler components recursively; the first three are the termination conditions for this recursion. To see what language a given expression denotes, we apply these rules repeatedly.</li>
</ul>
<p dir="auto">These rules allow us to formally define what strings a given regular expression matches, and how these expressions can be constructed from simpler expressions. The recursive nature of the definition is crucial to understanding and working with regular expressions.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_29.png" src="slides/Pasted image 20250209093807_29.png" class="internal-embed"></p>
<p dir="auto">This slide provides an example to demonstrate the concepts discussed in previous slides.</p>
<ul>
<li dir="auto"><strong>Alphabet:</strong> For Σ = {a, b}, the regular expression is defined over an alphabet of two characters 'a' and 'b'.</li>
<li dir="auto"><strong>Regular Expression:</strong> r = (a + b)*(a + bb)</li>
<li dir="auto"><strong>Language:</strong> L(r) = {a, bb, aa, abb, ba, bbb,...}. The language consists of strings starting with any combination of 'a' and 'b', terminated by either 'a' or 'bb'.</li>
<li dir="auto"><strong>Explanation:</strong>
<ul>
<li dir="auto">(a+b)* stands for any string of a's and b's.</li>
<li dir="auto">(a+bb) represents either an 'a' or a double 'b'.</li>
<li dir="auto">So the resulting language is the set of all strings on {a, b} terminated by either an a or a bb.</li>
</ul>
</li>
</ul>
<p dir="auto">This example clearly demonstrates how to interpret and understand the language defined by a regular expression.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_30.png" src="slides/Pasted image 20250209093807_30.png" class="internal-embed"></p>
<p dir="auto">This slide presents another example to further illustrate regular expressions.</p>
<ul>
<li dir="auto"><strong>Regular Expression:</strong>  r = (aa)*(bb)*b</li>
<li dir="auto"><strong>Language Description:</strong> The regular expression denotes the set of all strings with an even number of a's followed by an odd number of b's.</li>
<li dir="auto"><strong>Formal Language:</strong> The language can be written formally as L(r) = {a^(2n)b^(2m+1): n ≥ 0, m ≥ 0}. This is the set of strings where the number of 'a's is a multiple of 2 (even), and the number of 'b's is an odd number.</li>
</ul>
<p dir="auto">This example highlights the use of repetition and concatenation to define complex string patterns.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_31.png" src="slides/Pasted image 20250209093807_31.png" class="internal-embed"></p>
<p dir="auto">This slide provides another example of how to construct a regular expression, including the reasoning behind the solution.</p>
<ul>
<li dir="auto"><strong>Alphabet:</strong> For Σ = {0, 1}, the alphabet consists of the characters 0 and 1.</li>
<li dir="auto"><strong>Language Description:</strong> L(r) = {w ∈ Σ*: w has at least one pair of consecutive zeros}.</li>
<li dir="auto"><strong>Reasoning and Solution:</strong> The slide walks us through the thought process to create the regular expression.
<ul>
<li dir="auto">Every string in L(r) must contain "00" somewhere.</li>
<li dir="auto">But what comes before and what goes after "00" is completely arbitrary.</li>
<li dir="auto">An arbitrary string on {0, 1} can be denoted by (0 + 1)*.</li>
<li dir="auto">Putting these observations together, the regular expression is: r = (0 + 1)*00(0 + 1)*.</li>
</ul>
</li>
</ul>
<p dir="auto">This example shows a structured approach to constructing a regular expression by considering the components of the desired strings.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_32.png" src="slides/Pasted image 20250209093807_32.png" class="internal-embed"></p>
<p dir="auto">This slide points out that multiple regular expressions can represent the same language.</p>
<ul>
<li dir="auto"><strong>Language Description:</strong> The language L = {w ∈ {a, b}* : w contains an odd number of a's}. This describes strings containing an odd number of 'a's.</li>
<li dir="auto"><strong>Two Regular Expressions:</strong> The slide presents two regular expressions that both define the same language:
<ul>
<li dir="auto">b*(ab*ab*)* a b*</li>
<li dir="auto">b* a b* (ab*ab*)*</li>
</ul>
</li>
<li dir="auto"><strong>Explanation:</strong> Both of these regular expressions capture the essence of having an odd number of 'a's. They both require that there is a single 'a' somewhere in the strings. Additional 'a's can occur, but they have to come in pairs.
<ul>
<li dir="auto">In the first expression, the last 'a' in the string acts as the required odd 'a'.</li>
<li dir="auto">In the second expression, the first 'a' serves the same purpose.</li>
</ul>
</li>
</ul>
<p dir="auto">This demonstrates that a single language can be described by multiple regular expressions, which can have different structures but still capture the same set of valid strings.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093807_33.png" src="slides/Pasted image 20250209093807_33.png" class="internal-embed"></p>
<p dir="auto">This slide discusses some regular expression idioms.</p>
<ul>
<li dir="auto"><strong>(a ∪ ε):</strong> This can be read as "optional a," since the expression can be satisfied either by matching 'a' or by matching the empty string (ε).</li>
<li dir="auto"><strong>(a ∪ b)*:</strong> This describes the set of all strings composed of the characters a and b. More generally, given any alphabet Σ = {c1, c2, ..., cn}, the language Σ* is described by the regular expression: (c1 ∪ c2 ∪ ... ∪ cn)*.</li>
<li dir="auto"><strong>Details Matter:</strong> When writing regular expressions, the details matter. The slide provides two examples to demonstrate this:
<ul>
<li dir="auto">a* ∪ b* ≠ (a ∪ b)*: The language on the right contains the string "ab", while the language on the left does not. Every string in the language on the left contains only a's or only b's.</li>
<li dir="auto">(ab)* ≠ a*b*: The language on the left contains the string "abab," while the language on the right does not. The language on the right contains the string "aaabbbb," while the language on the left does not.</li>
</ul>
</li>
</ul>
<p dir="auto">These examples highlight that careful attention is needed when designing regular expressions. Subtle differences in the expression can lead to significant differences in the language that is defined.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093808_34.png" src="slides/Pasted image 20250209093808_34.png" class="internal-embed"></p>
<p dir="auto">This slide demonstrates how to analyze a regular expression to determine the language it represents.</p>
<ul>
<li dir="auto"><strong>Regular Expression:</strong> (a ∪ b)*b</li>
<li dir="auto"><strong>Analysis:</strong>
<ul>
<li dir="auto">L((a ∪ b)*b) = L((a ∪ b)*) L(b) (concatenation)</li>
<li dir="auto">= (L((a ∪ b)))* L(b) (parenthesis doesn't affect)</li>
<li dir="auto">= (L(a) ∪ L(b))* L(b) ("∪" represents alternation)</li>
<li dir="auto">= ({a} ∪ {b})* {b} (each character 'a' or 'b' represents a set that contains them)</li>
<li dir="auto">= {a, b}* {b}</li>
</ul>
</li>
<li dir="auto"><strong>Meaning:</strong> So, the meaning of the regular expression (a ∪ b)*b is the set of all strings over the alphabet {a, b} that end in b.</li>
</ul>
<p dir="auto">The slide breaks down the expression step by step, applying the rules of regular expression definition.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093808_35.png" src="slides/Pasted image 20250209093808_35.png" class="internal-embed"></p>
<p dir="auto">This slide provides another example of regular expression analysis.</p>
<ul>
<li dir="auto"><strong>Regular Expression:</strong> ((a ∪ b)(a ∪ b)) a (a ∪ b)*</li>
<li dir="auto"><strong>Analysis:</strong>
<ul>
<li dir="auto">L(((a ∪ b)(a ∪ b)) a (a ∪ b)*) = L(((a ∪ b)(a ∪ b)) a) L((a ∪ b)*) (concatenation)</li>
<li dir="auto">= L((a ∪ b)(a ∪ b)) {a} (L((a ∪ b)))*</li>
<li dir="auto">= L((a ∪ b)) L((a ∪ b)) {a} {a, b}*</li>
<li dir="auto">= {a, b} {a, b} {a} {a, b}*</li>
</ul>
</li>
<li dir="auto"><strong>Meaning:</strong>  The meaning of the regular expression ((a ∪ b)(a ∪ b)) a (a ∪ b)* is:
<ul>
<li dir="auto">{xay: x and y are strings of a's and b's and |x| = 2} which is a set where x and y are strings of 'a' and 'b' such that the length of x is equal to 2.</li>
<li dir="auto">Alternatively, it is the language that contains all strings of a's and b's such that there exists a third character, and it is an 'a'.</li>
</ul>
</li>
</ul>
<p dir="auto">This example illustrates how to interpret more complex regular expressions, showing the step-by-step breakdown and the resulting meaning of the expression.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093808_36.png" src="slides/Pasted image 20250209093808_36.png" class="internal-embed"></p>
<p dir="auto">This slide looks at finding a regular expression for a given language. This demonstrates how we can reverse the process.</p>
<ul>
<li dir="auto"><strong>Language:</strong>  L = {w ∈ {a, b}*: |w| is even}. This means the language includes strings of 'a's and 'b's with an even number of characters.</li>
<li dir="auto"><strong>Regular Expressions:</strong>  The slide gives two regular expressions that satisfy this language:
<ul>
<li dir="auto">((a ∪ b)(a ∪ b))*</li>
<li dir="auto">(aa ∪ ab ∪ ba ∪ bb)*</li>
</ul>
</li>
<li dir="auto"><strong>Explanation:</strong>
<ul>
<li dir="auto">((a ∪ b)(a ∪ b))*: This can be read as "Go through a loop zero or more times. Each time through, choose an a or b, then choose a second character (a or b)." This ensures that characters are selected in pairs.</li>
<li dir="auto">(aa ∪ ab ∪ ba ∪ bb)*: This can be read as, "Go through a loop zero or more times. Each time through, choose one of the two-character sequences."</li>
</ul>
</li>
</ul>
<p dir="auto">This demonstrates that we can express a language with more than one regular expression.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093808_37.png" src="slides/Pasted image 20250209093808_37.png" class="internal-embed"></p>
<p dir="auto">This slide provides links to external resources for further study on regular expressions.</p>
<ul>
<li dir="auto"><strong>Resources:</strong>
<ul>
<li dir="auto"><a rel="noopener nofollow" class="external-link" href="https://www.javatpoint.com/examples-of-regular-expression" target="_blank">https://www.javatpoint.com/examples-of-regular-expression</a></li>
<li dir="auto"><a rel="noopener nofollow" class="external-link" href="https://www.w3schools.com/python/python_regex.asp" target="_blank">https://www.w3schools.com/python/python_regex.asp</a></li>
</ul>
</li>
</ul>
<p dir="auto">These links should provide useful examples and explanations, so that you can extend the information and practice of the presented topics.</p>
<p dir="auto"><img alt="slides/Pasted image 20250209093808_38.png" src="slides/Pasted image 20250209093808_38.png" class="internal-embed"></p>
<p dir="auto">The session appears to be concluding. This slide simply says, "Thank you."</p>
    </body>
</html>